<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · TumorGrowth</title><meta name="title" content="Reference · TumorGrowth"/><meta property="og:title" content="Reference · TumorGrowth"/><meta property="twitter:title" content="Reference · TumorGrowth"/><meta name="description" content="Documentation for TumorGrowth."/><meta property="og:description" content="Documentation for TumorGrowth."/><meta property="twitter:description" content="Documentation for TumorGrowth."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TumorGrowth</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../quick_start/">Quick start</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ablaom/TumorGrowth.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ablaom/TumorGrowth.jl/blob/dev/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth.TumorGrowth</code></a></li><li><a href="#TumorGrowth.CalibrationProblem-Tuple{CalibrationProblem}"><code>TumorGrowth.CalibrationProblem</code></a></li><li><a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>TumorGrowth.CalibrationProblem</code></a></li><li><a href="#TumorGrowth.WeightedL2Loss"><code>TumorGrowth.WeightedL2Loss</code></a></li><li><a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy</code></a></li><li><a href="#TumorGrowth.bertalanffy2-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy2</code></a></li><li><a href="#TumorGrowth.bertalanffy2_ode!-NTuple{4, Any}"><code>TumorGrowth.bertalanffy2_ode!</code></a></li><li><a href="#TumorGrowth.bertalanffy_numerical-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy_numerical</code></a></li><li><a href="#TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}"><code>TumorGrowth.bertalanffy_ode</code></a></li><li><a href="#TumorGrowth.classical_bertalanffy-Tuple{Any, Any}"><code>TumorGrowth.classical_bertalanffy</code></a></li><li><a href="#TumorGrowth.compare-Tuple"><code>TumorGrowth.compare</code></a></li><li><a href="#TumorGrowth.constraint_function-Tuple{Any}"><code>TumorGrowth.constraint_function</code></a></li><li><a href="#TumorGrowth.curvature-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T"><code>TumorGrowth.curvature</code></a></li><li><a href="#TumorGrowth.errors-Tuple{ModelComparison}"><code>TumorGrowth.errors</code></a></li><li><a href="#TumorGrowth.flat_patient_data-Tuple{}"><code>TumorGrowth.flat_patient_data</code></a></li><li><a href="#TumorGrowth.gompertz-Tuple{Any, Any}"><code>TumorGrowth.gompertz</code></a></li><li><a href="#TumorGrowth.guess_parameters-Tuple{Any, Any, Any}"><code>TumorGrowth.guess_parameters</code></a></li><li><a href="#TumorGrowth.logistic-Tuple{Any, Any}"><code>TumorGrowth.logistic</code></a></li><li><a href="#TumorGrowth.loss-Tuple"><code>TumorGrowth.loss</code></a></li><li><a href="#TumorGrowth.merge-Tuple{Any, Any}"><code>TumorGrowth.merge</code></a></li><li><a href="#TumorGrowth.n_iterations-Tuple{Any}"><code>TumorGrowth.n_iterations</code></a></li><li><a href="#TumorGrowth.neural-Tuple"><code>TumorGrowth.neural</code></a></li><li><a href="#TumorGrowth.neural2-Tuple"><code>TumorGrowth.neural2</code></a></li><li><a href="#TumorGrowth.neural_ode-Tuple{Any, Any}"><code>TumorGrowth.neural_ode</code></a></li><li><a href="#TumorGrowth.options-Tuple{Any}"><code>TumorGrowth.options</code></a></li><li><a href="#TumorGrowth.parameters-Tuple{ModelComparison}"><code>TumorGrowth.parameters</code></a></li><li><a href="#TumorGrowth.patient_data-Tuple{}"><code>TumorGrowth.patient_data</code></a></li><li><a href="#TumorGrowth.recover-Tuple{Any, Any}"><code>TumorGrowth.recover</code></a></li><li><a href="#TumorGrowth.scale_function-Tuple{Any, Any, Any}"><code>TumorGrowth.scale_function</code></a></li><li><a href="#TumorGrowth.solution-Tuple{CalibrationProblem}"><code>TumorGrowth.solution</code></a></li><li><a href="#TumorGrowth.solve!-Tuple"><code>TumorGrowth.solve!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}" href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>TumorGrowth.CalibrationProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    CalibrationProblem(times, volumes, model; learning_rate=0.0001, options...)</code></pre><p>Specify a problem concerned with optimizing the parameters of a tumor growth <code>model</code>, given measured <code>volumes</code> and corresponding <code>times</code>.</p><p>See <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a> for a list of possible <code>model</code>s.</p><p>Default optimisation is by Adam gradient descent, using a sum of squares loss. Call <code>solve!</code> on a problem to carry out optimisation, as shown in the example below. See &quot;Extended Help&quot; for advanced options, including early stopping.</p><p>Initial values of the parameters are inferred by default.</p><p>Unless frozen (see &quot;Extended help&quot; below), the calibration process learns an initial condition <code>v0</code> which is generally different from <code>volumes[1]</code>.</p><p><strong>Simple solve</strong></p><pre><code class="language-julia hljs">using TumorGrowth

times = [0.1, 6.0, 16.0, 24.0, 32.0, 39.0]
volumes = [0.00023, 8.4e-5, 6.1e-5, 4.3e-5, 4.3e-5, 4.3e-5]
problem = CalibrationProblem(times, volumes, gompertz; learning_rate=0.01)
solve!(problem, 30)    # apply 30 gradient descent updates
julia&gt; loss(problem)   # sum of squares loss
1.7341026729860452e-9

p = solution(problem)
julia&gt; pretty(p)
&quot;v0=0.0002261  v∞=2.792e-5  ω=0.05731&quot;


extended_times = vcat(times, [42.0, 46.0])
julia&gt; gompertz(extended_times, p)[[7, 8]]
2-element Vector{Float64}:
 3.374100207406809e-5
 3.245628908921241e-5</code></pre><p><strong>Extended help</strong></p><p><strong>Solving with iteration controls</strong></p><p>Continuing the example above, we may replace the number of iterations, <code>n</code>, in <code>solve!(problem, n)</code>, with any control from IterationControl.jl:</p><pre><code class="language-julia hljs">using IterationControl
solve!(
  problem,
  Step(1),            # apply controls every 1 iteration...
  WithLossDo(),       # print loss
  Callback(problem -&gt; print(pretty(solution(problem)))), # print parameters
  InvalidValue(),     # stop for ±Inf/NaN loss, incl. case of out-of-bound parameters
  NumberSinceBest(5), # stop when lowest loss so far was 5 steps prior
  TimeLimit(1/60),    # stop after one minute
  NumberLimit(400),   # stop after 400 steps
)
p = solution(problem)
julia&gt; loss(problem)
7.609310030658547e-10</code></pre><p>See <a href="https://github.com/JuliaAI/IterationControl.jl">IterationControl.jl</a> for all options.</p><p><strong>Visualizing results</strong></p><pre><code class="language-julia hljs">using Plots
scatter(times, volumes, xlab=&quot;time&quot;, ylab=&quot;volume&quot;, label=&quot;train&quot;)
plot!(problem, label=&quot;prediction&quot;)</code></pre><p><strong>Keyword options</strong></p><ul><li><p><code>p0</code>: initial value of the model parameters; inferred by default for built-in models</p></li><li><p><code>g=(p-&gt; true)</code>: constraint function: If <code>g(p) == false</code> for some parameter <code>p</code>, then a warning is given and <code>solution(problem)</code> is frozen at the last constrained value of <code>p</code>; use <code>solve!(problem, Step(1), InvalidValue(), ...)</code> to ensure early stopping (which works because <code>IterationControl.loss(problem)</code> will return <code>Inf</code> in that case). If unspecified, the constraint function is inferred in the case of built-in models and parameters are otherwise unconstrained.</p></li><li><p><code>frozen</code>: a named tuple, such as <code>(; v0=nothing, λ=1/2)</code>; indicating parameters to be frozen at specified values during optimization; a <code>nothing</code> value means freeze at initial value.</p></li><li><p><code>learning_rate=0.0001</code>: learning rate for Adam gradient descent optimiser</p></li><li><p><code>optimiser=Optimisers.Adam(learning_rate)</code>: optimiser; must be from Optimisers.jl.</p></li><li><p><code>scale</code>: a scaling function with the property that <code>p = scale(q)</code> has a value of the same order of magnitude for the model parameters being optimised, whenever <code>q</code> has the same form as a model parameter <code>p</code> but with all values equal to one. Scaling ensures gradient descent learns all components of <code>p</code> at a similar rate. If unspecified, scaling is inferred for built-in models, and uniform otherwise.</p></li><li><p><code>half_life=Inf</code>: set to a real positive number to replace the sum of squares loss with a weighted version; weights decay in reverse time with the specified <code>half_life</code></p></li><li><p><code>penalty=0.0</code> (range=<span>$[0, ∞)$</span>): the larger the positive value, the more a loss function modification discourages large differences in <code>v0</code> and <code>v∞</code> on a log scale. Helps discourage <code>v0</code> and <code>v∞</code> drifting out of bounds in models whose ODE have a singularity at the origin.</p></li><li><p><code>ode_options...</code>: optional keyword arguments for the ODE solver, <code>DifferentialEquations.solve</code>, from DifferentialEquations.jl. Not relevant for models using analytic solutions (see the table at <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>.y</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/calibration.jl#L37-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.CalibrationProblem-Tuple{CalibrationProblem}" href="#TumorGrowth.CalibrationProblem-Tuple{CalibrationProblem}"><code>TumorGrowth.CalibrationProblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CalibrationProblem(problem; kwargs...)</code></pre><p>Construct a new calibration problem out an existing <code>problem</code> but supply new keyword arguments, <code>kwargs</code>. Unspecified keyword arguments fall back to defaults, except for <code>p0</code>, which falls back to <code>solution(problem)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/calibration.jl#L217-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.bertalanffy-Tuple{Any, Any}" href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bertalanffy(times, p)</code></pre><p>Return volumes for specified <code>times</code>, based on the analytic solution to the generalized Bertalanffy model for lesion growth.  Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, <code>λ</code>, where <code>v0</code> is the volume at time <code>times[1]</code>. Other parameters are explained below.</p><p>Special cases of the model are:</p><ul><li><a href="#TumorGrowth.logistic-Tuple{Any, Any}"><code>logistic</code></a> (<code>λ = -1</code>)</li><li><a href="#TumorGrowth.classical_bertalanffy-Tuple{Any, Any}"><code>classical_bertalanffy</code></a>  (<code>λ = 1/3</code>)</li><li><a href="#TumorGrowth.gompertz-Tuple{Any, Any}"><code>gompertz</code></a> (<code>λ = 0</code>)</li></ul><p><strong>Underlying ODE</strong></p><p>In the generalized Bertalanffy model, the volume <span>$v &gt; 0$</span> evolves according to the differential equation</p><p><span>$dv/dt = ω B_λ(v∞/v) v,$</span></p><p>where <span>$B_λ$</span> is the Box-Cox transformation, defined by <span>$B_λ(x) = (x^λ - 1)/λ$</span>, unless <span>$λ = 0$</span>, in which case, <span>$B_λ(x) = \log(x)$</span>. Here:</p><ul><li><span>$v∞$</span> is the steady state solution, stable and unique, assuming <span>$ω &gt; 0$</span>; this is  sometimes referred to as the <em>carrying capacity</em></li><li><span>$1/ω$</span> has the units of time</li><li><span>$λ$</span> is dimensionless</li></ul><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/models/bertalanffy.jl#L6-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.bertalanffy2-Tuple{Any, Any}" href="#TumorGrowth.bertalanffy2-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bertalanffy2(times, p; capacity=false, solve_kwargs...)</code></pre><p>Return volumes for specified <code>times</code>, based on numerical solutions to a two-dimensional extension of generalized Bertalanffy model for lesion growth. Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, <code>λ</code>, <code>γ</code>, where <code>v0</code> is the volume at time <code>times[1]</code>.</p><p>The usual generalized Bertalanffy model is recovered when <code>γ=0</code>. In that case, using <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a>, which is based on an analytic solution, may be preferred. Other parameters are explained below.</p><p><strong>Keyword options</strong></p><ul><li><p><code>capacity=false</code>: Set to <code>true</code> to return the latent &quot;carrying capacity&quot; variable, in addition to the actual volumes.</p></li><li><p><code>solve_kwargs</code>: optional keyword arguments for the ODE solver, <code>DifferentialEquations.solve</code>, from DifferentialEquations.jl.</p></li></ul><p><strong>Underlying ODE</strong></p><p>In this model the carrying capacity of the <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a> model, ordinarily fixed, is introduced as a new latent variable <span>$u(t)$</span>, which is allowed to evolve independently of the volume <span>$v(t)$</span>, at a rate in proportion to its magnitude:</p><p><span>$dv/dt = ω B_λ(u/v) v$</span></p><p><span>$du/dt = γωu$</span></p><p>Here <span>$B_λ$</span> is the Box-Cox transformation with exponent <span>$λ$</span>. See <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a>. Also:</p><ul><li><span>$1/ω$</span> has units of time</li><li><span>$λ$</span> is dimensionless</li><li><span>$γ$</span> is dimensionless</li></ul><p>Since <span>$u$</span> is a latent variable, its initial value, <code>v∞ ≡ u(times[1])</code>, is an additional model parameter.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/models/bertalanffy2.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.bertalanffy_numerical-Tuple{Any, Any}" href="#TumorGrowth.bertalanffy_numerical-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy_numerical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bertalanffy_numerical(times, p; solve_kwargs...)</code></pre><p><em>Provided for testing purposes.</em></p><p>Return volumes for specified <code>times</code>, based on numerical solutions to the generalized Bertalanffy model for lesion growth. Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, <code>λ</code>, where <code>v0</code> is the volume at time <code>times[1]</code>; <code>solve_kwargs</code> are optional keyword arguments for the ODE solver, <code>DifferentialEquations.solve</code>, from DifferentialEquations.jl.</p><p>Since it is based on analtic solutions, <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a> is the preferred alternative to this function.</p><div class="admonition is-category-important"><header class="admonition-header">Important</header><div class="admonition-body"><p>It is assumed without checking that <code>times</code> is ordered: <code>times == sort(times)</code>.</p></div></div><p>See also <a href="#TumorGrowth.bertalanffy2-Tuple{Any, Any}"><code>bertalanffy2</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/models/bertalanffy_numerical.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.classical_bertalanffy-Tuple{Any, Any}" href="#TumorGrowth.classical_bertalanffy-Tuple{Any, Any}"><code>TumorGrowth.classical_bertalanffy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">classical_bertalanffy(times, v0, v∞, ω)</code></pre><p>Return volumes for specified <code>times</code>, based on anaytic solutions to the classical Bertalanffy model for lesion growth. Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, where <code>v0</code> is the volume at time <code>times[1]</code>.</p><p>This is the <code>λ=1/3</code> case of the <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a> model.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/models/classical_bertalanffy.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.compare-Tuple" href="#TumorGrowth.compare-Tuple"><code>TumorGrowth.compare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compare(times, volumes, models; holdouts=3, metric=mae, advanced_options...)</code></pre><p>By calibrating <code>models</code> using the specified patient <code>times</code> and lesion <code>volumes</code>, compare those models using a hold-out set consisting of the last <code>holdouts</code> data points.</p><pre><code class="language-julia hljs">times = [0.1, 6.0, 16.0, 24.0, 32.0, 39.0]
volumes = [0.00023, 8.4e-5, 6.1e-5, 4.3e-5, 4.3e-5, 4.3e-5]

julia&gt; comparison = compare(times, volumes, [gompertz, logistic])
ModelComparison with 3 holdouts:
  metric: mae
  gompertz:     2.198e-6
  logistic:     6.55e-6

julia&gt; errors(comparison)
2-element Vector{Float64}:
 2.197843662660861e-6
 6.549858321487298e-6

julia&gt; p = parameters(comparison)[1]  # calibrated parameter for `gompertz`
(v0 = 0.00022643603114569068, v∞ = 3.8453274218216947e-5, ω = 0.11537512108224635)

julia&gt; gompertz(times, p)
6-element Vector{Float64}:
 0.00022643603114569068
 9.435316392754094e-5
 5.1039159299783234e-5
 4.303209015899451e-5
 4.021112910411027e-5
 3.922743006690166e-5</code></pre><p>When a model parameter becomes out of bounds, calibration stops early and the last in-bounds value is reported.</p><p><strong>Visualing comparisons</strong></p><pre><code class="language-julia hljs">using Plots
plot(comparison, title=&quot;A comparison of two models&quot;)</code></pre><p><strong>Keyword options</strong></p><ul><li><p><code>holdouts=3</code>: number of time-volume pairs excluded from the end of the calibration data</p></li><li><p><code>metric=mae</code>: metric applied to holdout set; the reported error on a model predicting volumes <code>v̂</code> is <code>metric(v̂, v)</code> where <code>v</code> is the last <code>holdouts</code> values of <code>volumes</code>. For example, any regression measure from StatisticalMeasures.jl can be used here. The built-in fallback is mean absolute error.</p></li><li><p><code>n_iterations=TumorGrowth.n_iterations.(models)</code>: a vector of iteration counts for the calibration of <code>models</code></p></li><li><p><code>calibration_options=TumorGrowth.options.(models)</code>: a vector of named tuples providing the keyword arguments for <code>CalibrationProblem</code>s - one for each model. See <a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>CalibrationProblem</code></a> for details.</p></li><li><p><code>flag_out_of_bounds=false</code>: set to <code>true</code> to report <code>NaN</code> as the error for a model whose parameter became out of bounds during calibration. Otherwise, the error for the last in-bounds parameter is reported.</p></li></ul><p>See also <a href="#TumorGrowth.errors-Tuple{ModelComparison}"><code>errors</code></a>, <a href="#TumorGrowth.parameters-Tuple{ModelComparison}"><code>parameters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/compare.jl#L65-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.errors-Tuple{ModelComparison}" href="#TumorGrowth.errors-Tuple{ModelComparison}"><code>TumorGrowth.errors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">errors(comparison)</code></pre><p>Extract the the vector of errors from a <code>ModelComparison</code> object, as returned by calls to <a href="#TumorGrowth.compare-Tuple"><code>compare</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/compare.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.flat_patient_data-Tuple{}" href="#TumorGrowth.flat_patient_data-Tuple{}"><code>TumorGrowth.flat_patient_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flat_patient_data()</code></pre><p>Return, in row table form, the lesion measurement data collected in Laleh et al. <a href="https://doi.org/10.1371/journal.pcbi.1009822">(2022)</a> &quot;Classical mathematical models for prediction of response to chemotherapy and immunotherapy&quot;, <em>PLOS Computational Biology</em>.</p><p>Each row represents a single measurement of a single lesion on some day.</p><p>See also <a href="#TumorGrowth.patient_data-Tuple{}"><code>patient_data</code></a>, in which each row represents all measurements of a single lesion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/patient_data.jl#L6-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.gompertz-Tuple{Any, Any}" href="#TumorGrowth.gompertz-Tuple{Any, Any}"><code>TumorGrowth.gompertz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gompertz(times, p)</code></pre><p>Return volumes for specified <code>times</code>, based on anaytic solutions to the classical Gompertz model for lesion growth. Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, where <code>v0</code> is the volume at time <code>times[1]</code>.</p><p>This is the <code>λ=0</code> case of the <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a> model.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/models/gompertz.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.guess_parameters-Tuple{Any, Any, Any}" href="#TumorGrowth.guess_parameters-Tuple{Any, Any, Any}"><code>TumorGrowth.guess_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">guess_parameters(times, volumes, model)</code></pre><p>Apply heuristics to guess parameters <code>p</code> for a model.</p><p><strong>New model implementations</strong></p><p>Fallback returns <code>nothing</code> which will prompt user&#39;s to explicitly specify initial parameter values in calibration problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/api.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.logistic-Tuple{Any, Any}" href="#TumorGrowth.logistic-Tuple{Any, Any}"><code>TumorGrowth.logistic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">logistic(times, v0, v∞, ω)</code></pre><p>Return volumes for specified <code>times</code>, based on anaytic solutions to the classical logistic (Verhulst) model for lesion growth. Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, where <code>v0</code> is the volume at time <code>times[1]</code>.</p><p>This is the <code>λ=-1</code> case of the <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a> model.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/models/logistic.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.loss-Tuple" href="#TumorGrowth.loss-Tuple"><code>TumorGrowth.loss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loss(problem)</code></pre><p>Return the sum of squares loss for a calibration <code>problem</code>, as constructed with <a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>CalibrationProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/optimisers.jl#L171-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.neural-Tuple" href="#TumorGrowth.neural-Tuple"><code>TumorGrowth.neural</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neural([rng,] network; transform=log, inverse=exp)</code></pre><p>Initialize the Lux.jl neural network, <code>network</code>, and return a callable object, <code>model</code>, for solving the associated one-dimensional neural ODE for volume growth, as detailed under &quot;Underlying ODE&quot; below.</p><p>The returned object, <code>model</code>, is called like this:</p><pre><code class="nohighlight hljs">volumes = model(times, p)</code></pre><p>where <code>p</code> should have properties <code>v0</code>, <code>v∞</code>, <code>θ</code>, where <code>v0</code> is the initial volume (so that <code>volumes[1] = v0</code>), <code>v∞</code> is a volume scale parameter, and <code>θ</code> is a <code>network</code>-compatible Lux.jl parameter.</p><p>It seems that calibration works best if <code>v∞</code> is frozen.</p><p>The form of <code>θ</code> is the same as <code>TumorGrowth.initial_parameters(model)</code>, which is also the default initial value used when solving an associated <a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>CalibrationProblem</code></a>.</p><pre><code class="language-julia hljs">using Lux, Random

# define neural network with 1 input and 1 output:
network = Lux.Chain(Dense(1, 3, Lux.tanh; init_weight=Lux.zeros64), Dense(3, 1))

rng = Xoshiro(123)
model = neural(rng, network)
θ = TumorGrowth.initial_parameters(model)
times = [0.1, 6.0, 16.0, 24.0, 32.0, 39.0]
v0, v∞ = 0.00023, 0.00015
p = (; v0, v∞, θ)

julia&gt; volumes = model(times, p) # (constant because of zero-initialization)
6-element Vector{Float64}:
 0.00023
 0.00023
 0.00023
 0.00023# # Neural2</code></pre><p><strong>Underlying ODE</strong></p><p>View the neural network (with fixed parameter <code>θ</code>) as a mathematical function <span>$f$</span> and write <span>$ϕ$</span> for the <code>transform</code> function. Then <span>$v(t) = ϕ^{-1}(y(t))$</span>, where <code>y(t)</code> evolves according to</p><p><span>$dy/dt = f(v)$</span></p><p>subject to the initial condition <span>$y(t₀) = ϕ(v0)$</span>, where <span>$t₀$</span> is the initial time, <code>times[1]</code>.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>.  See also <a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>CalibrationProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/models/neural.jl#L7-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.neural2-Tuple" href="#TumorGrowth.neural2-Tuple"><code>TumorGrowth.neural2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neural2([rng,] network; transform=log, inverse=exp)</code></pre><p>Initialize the Lux.jl neural network, <code>network</code>, and return a callable object, <code>model</code>, for solving the associated two-dimensional neural2 ODE for volume growth, as detailed under &quot;Underlying ODE&quot; below.</p><p>The returned object <code>model</code> is called like this:</p><pre><code class="nohighlight hljs">volumes = model(times, p)</code></pre><p>where <code>p</code> should have properties <code>v0</code>, <code>v∞</code>, <code>θ</code>, where <code>v0</code> is the initial volume (so that <code>volumes[1] = v0</code>), <code>v∞</code> is a volume scale parameter, and <code>θ</code> is a <code>network</code>-compatible Lux.jl parameter.</p><p>It seems that calibration works best if <code>v∞</code> is frozen.</p><p>The form of <code>θ</code> is the same as <code>TumorGrowth.initial_parameters(model)</code>, which is also the default initial value used when solving an associated <a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>CalibrationProblem</code></a>.</p><pre><code class="language-julia hljs">using Lux, Random

# define neural network with 2 inputs and 2 outputs:
network = Lux.Chain(Dense(2, 3, Lux.tanh; init_weight=Lux.zeros64), Dense(3, 2))

rng = Xoshiro(123)
model = neural2(rng, network)
θ = TumorGrowth.initial_parameters(model)
times = [0.1, 6.0, 16.0, 24.0, 32.0, 39.0]
v0, v∞ = 0.00023, 0.00015
p = (; v0, v∞, θ)

julia&gt; volumes = model(times, p) # (constant because of zero-initialization)
6-element Vector{Float64}:
 0.00023
 0.00023
 0.00023
 0.00023
 0.00023
 0.00023</code></pre><p><strong>Underlying ODE</strong></p><p>View the neural network (with fixed parameter <code>θ</code>) as a mathematical function <span>$f$</span>, with components <code>f₁</code> and <code>f₂</code>, and write <span>$ϕ$</span> for the <code>transform</code> function. Then <span>$v(t) = ϕ^{-1}(y(t))$</span>, where <code>y(t)</code>, and a latent variable <code>u(t)</code>, evolve according to</p><p><span>$dy/dt = f₁(v, u)$</span></p><p><span>$du/dt = f₂(v, u)$</span></p><p>subject to the initial conditions <span>$y(t₀) = ϕ(v0)$</span>, <span>$u(t₀) = 1$</span>, where <span>$t₀$</span> is the initial time, <code>times[1]</code>.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>.  See also <a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>CalibrationProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/models/neural2.jl#L7-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.parameters-Tuple{ModelComparison}" href="#TumorGrowth.parameters-Tuple{ModelComparison}"><code>TumorGrowth.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">errors(comparison)</code></pre><p>Extract the the vector of errors from a <code>ModelComparison</code> object, as returned by calls to <a href="#TumorGrowth.compare-Tuple"><code>compare</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/compare.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.patient_data-Tuple{}" href="#TumorGrowth.patient_data-Tuple{}"><code>TumorGrowth.patient_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">patient_data()</code></pre><p>Return, in row table form, the lesion measurement data collected in Laleh et al. <a href="https://doi.org/10.1371/journal.pcbi.1009822">(2022)</a> &quot;Classical mathematical models for prediction of response to chemotherapy and immunotherapy&quot;, <em>PLOS Computational Biology</em>.</p><p>Each row represents all measurements for a single lesion for a unique patient.</p><pre><code class="language-julia hljs">record = first(patient_data())

julia&gt; record.Pt_hashID # patient identifier
&quot;0218075314855e6ceacca856fcd4c737-S1&quot;

julia&gt; record.T_weeks # measure times, in weeks
7-element Vector{Float64}:
  0.1
  6.0
 12.0
 17.0
 23.0
 29.0
 35.0

julia&gt; record.Lesion_normvol # all volumes measured, normalised by dataset max
7-element Vector{Float64}:
 0.000185364052636979
 0.00011229838600811
 8.4371439525252e-5
 8.4371439525252e-5
 1.05464299406565e-5
 2.89394037571615e-5
 8.4371439525252e-5</code></pre><p>See also <a href="#TumorGrowth.flat_patient_data-Tuple{}"><code>flat_patient_data</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/patient_data.jl#L50-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.solution-Tuple{CalibrationProblem}" href="#TumorGrowth.solution-Tuple{CalibrationProblem}"><code>TumorGrowth.solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solution(problem)</code></pre><p>Return to the solution to a <a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>CalibrationProblem</code></a>. Normally applied after calling <a href="#TumorGrowth.solve!-Tuple"><code>solve!(problem)</code></a>.</p><p>Also returns the solution to internally defined problems, as constructed with <code>TumorGrowth.OptimisationProblem</code>, <code>TumorGrowth.CurveOptimisationProblem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/calibration.jl#L237-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.solve!-Tuple" href="#TumorGrowth.solve!-Tuple"><code>TumorGrowth.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(problem, n)</code></pre><p>Solve a calibration <code>problem</code>, as constructed with <a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>CalibrationProblem</code></a>. The calibrated parameters are then returned by <code>solution(problem)</code>.</p><hr/><pre><code class="nohighlight hljs">solve!(problem, controls...)</code></pre><p>Solve a calibration <code>problem</code> using one or more iteration <code>controls</code>, from the package IterationControls.jl. See the &quot;Extended help&quot; section of <a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>CalibrationProblem</code></a> for examples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/optimisers.jl#L154-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.TumorGrowth" href="#TumorGrowth.TumorGrowth"><code>TumorGrowth.TumorGrowth</code></a> — <span class="docstring-category">Module</span></header><section><div><p>TumorGrowth.jl provides the following models for tumor growth:</p><table><tr><th style="text-align: left">model</th><th style="text-align: left">description</th><th style="text-align: left">parameters, <code>p</code></th><th style="text-align: left">analytic?</th><th style="text-align: left">ODE</th></tr><tr><td style="text-align: left"><a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a></td><td style="text-align: left">generalized Bertalanffy (GB)</td><td style="text-align: left"><code>(; v0, v∞, ω, λ)</code></td><td style="text-align: left">yes</td><td style="text-align: left"><a href="#TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}"><code>TumorGrowth.bertalanffy_ode</code></a></td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.bertalanffy_numerical-Tuple{Any, Any}"><code>bertalanffy_numerical</code></a></td><td style="text-align: left">generalized Bertalanffy (testing only)</td><td style="text-align: left"><code>(; v0, v∞, ω, λ)</code></td><td style="text-align: left">no</td><td style="text-align: left"><a href="#TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}"><code>TumorGrowth.bertalanffy_ode</code></a></td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.bertalanffy2-Tuple{Any, Any}"><code>bertalanffy2</code></a></td><td style="text-align: left">2D extension of generalized Bertalanffy</td><td style="text-align: left"><code>(; v0, v∞, ω, λ, γ)</code></td><td style="text-align: left">no</td><td style="text-align: left"><a href="#TumorGrowth.bertalanffy2_ode!-NTuple{4, Any}"><code>TumorGrowth.bertalanffy2_ode!</code></a></td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.gompertz-Tuple{Any, Any}"><code>gompertz</code></a></td><td style="text-align: left">Gompertz (GB, <code>λ=0</code>)</td><td style="text-align: left"><code>(; v0, v∞, ω)</code></td><td style="text-align: left">yes</td><td style="text-align: left"><a href="#TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}"><code>TumorGrowth.bertalanffy_ode</code></a></td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.logistic-Tuple{Any, Any}"><code>logistic</code></a></td><td style="text-align: left">logistic/Verhulst (GB, <code>λ=-1</code>)</td><td style="text-align: left"><code>(; v0, v∞, ω)</code></td><td style="text-align: left">yes</td><td style="text-align: left"><a href="#TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}"><code>TumorGrowth.bertalanffy_ode</code></a></td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.classical_bertalanffy-Tuple{Any, Any}"><code>classical_bertalanffy</code></a></td><td style="text-align: left">classical Bertalanffy (GB, <code>λ=1/3</code>)</td><td style="text-align: left"><code>(; v0, v∞, ω)</code></td><td style="text-align: left">yes</td><td style="text-align: left"><a href="#TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}"><code>TumorGrowth.bertalanffy_ode</code></a></td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.neural-Tuple"><code>neural(rng, network)</code></a></td><td style="text-align: left">1D neural ODE with Lux.jl <code>network</code></td><td style="text-align: left"><code>(; v0, v∞, θ)</code></td><td style="text-align: left">no</td><td style="text-align: left"><a href="#TumorGrowth.neural_ode-Tuple{Any, Any}"><code>TumorGrowth.neural_ode</code></a></td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.neural2-Tuple"><code>neural2(rng, network)</code></a></td><td style="text-align: left">2D neural ODE with Lux.jl <code>network</code></td><td style="text-align: left"><code>(; v0, v∞, θ)</code></td><td style="text-align: left">no</td><td style="text-align: left"><a href="#TumorGrowth.neural_ode-Tuple{Any, Any}"><code>TumorGrowth.neural_ode</code></a></td></tr></table><p>Here a <em>model</em> is a callable object, that outputs a sequence of lesion volumes, given times, by solving a related ordinary differential equation with parameters (<code>p</code> below):</p><pre><code class="language-julia hljs">using TumorGrowth

times = times = [0.1, 6.0, 16.0, 24.0, 32.0, 39.0]
p = (v0=0.0002261, v∞=2.792e-5,  ω=0.05731) # `v0` is the initial volume
volumes = gompertz(times, p)
6-element Vector{Float64}:
 0.0002261
 0.0001240760197801191
 6.473115210101774e-5
 4.751268597529182e-5
 3.9074807723757934e-5
 3.496675045077041e-5</code></pre><p>In every model, <code>v0</code> is the initial volume, so that <code>volumes[1] == v0</code>.</p><p>In the case analytic solutions to the underlying ODEs are not known, optional keyword arguments for the <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a> solver can be passed to the model call.</p><p>TumorGrowth.jl also provides a <a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>CalibrationProblem</code></a> tool to calibrate model parameters, and a <a href="#TumorGrowth.compare-Tuple"><code>compare</code></a> tool to compare models on a holdout set.</p><p>Calibration is performed using a gradient descent optimiser to minimise a (possibly weighted) least-squares error on provided clinical measurements, and uses the adjoint method to auto-differentiate solutions to the underlying ODE&#39;s, with respect to the ODE parameters, and initial conditions to be optimised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/TumorGrowth.jl#L1-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.WeightedL2Loss" href="#TumorGrowth.WeightedL2Loss"><code>TumorGrowth.WeightedL2Loss</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeightedL2Loss(times, h=Inf)</code></pre><p><em>Private method.</em></p><p>Return a weighted sum of squares loss function <code>(ŷ, y) -&gt; loss</code>, where the weights decay in reverse time with a half life <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/tools.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.bertalanffy2_ode!-NTuple{4, Any}" href="#TumorGrowth.bertalanffy2_ode!-NTuple{4, Any}"><code>TumorGrowth.bertalanffy2_ode!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bertalanffy2_ode!(dX, X, p, t)</code></pre><p>A two-dimensional extension of the ODE describing the generalized Bertalanffy model for lesion growth.  Here <code>X = [v, u]</code>, where <code>v</code> is volume at time <code>t</code> and <code>u</code> is the &quot;carrying capacity&quot; at time <code>t</code>, a latent variable. The time derivatives are written to <code>dX</code>. For the specific form of the ODE, see <a href="#TumorGrowth.bertalanffy2-Tuple{Any, Any}"><code>bertalanffy2</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/odes.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}" href="#TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}"><code>TumorGrowth.bertalanffy_ode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bertalanffy_ode(v, p, t)</code></pre><p>Based on the generalized Bertalanffy model, return the rate in change in volume at time <code>t</code>, for a current volume of <code>v</code>. For details, see <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/odes.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.constraint_function-Tuple{Any}" href="#TumorGrowth.constraint_function-Tuple{Any}"><code>TumorGrowth.constraint_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">constraint_function(model)</code></pre><p>Return an appropriate <code>Bool</code>-valued function <code>p -&gt; g(p)</code> which is <code>false</code> whenever parameter <code>p</code> leaves the natural domain of <code>model</code>.</p><p><strong>New model implementations</strong></p><p>Fallback returns <code>true</code> always.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/api.jl#L36-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.curvature-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T" href="#TumorGrowth.curvature-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T"><code>TumorGrowth.curvature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">curvature(xs, ys)</code></pre><p>Return the coefficient <code>a</code> for the parabola <code>x -&gt; a*x^2 + b*x + c</code> of best fit, for ordinates <code>xs</code> and coordinates <code>ys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/tools.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.merge-Tuple{Any, Any}" href="#TumorGrowth.merge-Tuple{Any, Any}"><code>TumorGrowth.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TumorGrowth.merge(x, y::NamedTuple)</code></pre><p><em>Private method.</em></p><p>Ordinary merge if <code>x</code> is also a named tuple. More generally, first deconstruct <code>x</code> using <code>TumorGrowth.functor</code>, merge as usual, and reconstruct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/tools.jl#L83-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.n_iterations-Tuple{Any}" href="#TumorGrowth.n_iterations-Tuple{Any}"><code>TumorGrowth.n_iterations</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_iterations(model)</code></pre><p>Default number of iterations to run calibration of <code>model</code> in model comparisons.</p><p><strong>New model implementations</strong></p><p>Fallback returns 10000</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/api.jl#L62-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.neural_ode-Tuple{Any, Any}" href="#TumorGrowth.neural_ode-Tuple{Any, Any}"><code>TumorGrowth.neural_ode</code></a> — <span class="docstring-category">Method</span></header><section><div><p>neural_ode([rng,] network)</p><p>Initialize the Lux.jl neural2 network, <code>network</code>, and return an associated ODE, <code>ode</code>, with calling syntax <code>dX_dt = ode(X, p, t)</code>, where <code>p</code> is a <code>network</code>-compatible parameter.</p><p>The initialized parameter value can be recovered with <code>TumorGrowth.initial_parameters(ode)</code>. Get the network state with <code>TumorGrowth.state(ode)</code>.</p><pre><code class="language-julia hljs">using Lux
using Random

rng = Xoshiro(123)
network = network = Lux.Chain(Lux.Dense(2, 3, Lux.tanh), Lux.Dense(3, 2))
ode = neural_ode(rng, network)
θ = TumorGrowth.initial_parameters(ode)
ode(rand(2), θ, 42.9) # last argument irrelevant as `ode` is autonomous</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/odes.jl#L44-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.options-Tuple{Any}" href="#TumorGrowth.options-Tuple{Any}"><code>TumorGrowth.options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">options(model)</code></pre><p>Default calibration options for <code>model</code> in model comparisons.</p><p><strong>New model implementations</strong></p><p>Fallback returns <code>(learning_rate=0.0001, penalty=0.8)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/api.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.recover-Tuple{Any, Any}" href="#TumorGrowth.recover-Tuple{Any, Any}"><code>TumorGrowth.recover</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recover(tuple, from)</code></pre><p><em>Private method.</em></p><p>Return a new tuple by replacing any <code>nothing</code> values with the corresponding value in the <code>from</code> tuple, whenever a corresponding key exists, and otherwise ignore.</p><pre><code class="language-julia hljs">julia&gt; recover((x=1, y=nothing, z=3, w=nothing), (x=10, y=2, k=7))
(x = 1, y = 2, z = 3, w = nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/tools.jl#L60-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.scale_function-Tuple{Any, Any, Any}" href="#TumorGrowth.scale_function-Tuple{Any, Any, Any}"><code>TumorGrowth.scale_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale_function(times, volumes, model)</code></pre><p>Return an appropriate function <code>p -&gt; f(p)</code> so that <code>p = f(q)</code> has a value of the same order of magnitude expected for <code>model</code> parameters, whenever <code>q</code> has the same form as <code>p</code> but with all values equal to one.</p><p><strong>New model implementations</strong></p><p>Fallback returns the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/8f327c92236d2475393d5b35f6c8d0c5f834ec4c/src/api.jl#L22-L33">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quick_start/">« Quick start</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 15 February 2024 19:18">Thursday 15 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
