<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · TumorGrowth.jl</title><meta name="title" content="Reference · TumorGrowth.jl"/><meta property="og:title" content="Reference · TumorGrowth.jl"/><meta property="twitter:title" content="Reference · TumorGrowth.jl"/><meta name="description" content="Documentation for TumorGrowth.jl."/><meta property="og:description" content="Documentation for TumorGrowth.jl."/><meta property="twitter:description" content="Documentation for TumorGrowth.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TumorGrowth.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../quick_start/">Quick start</a></li><li><a class="tocitem" href="../calibration/">Calibration</a></li><li><a class="tocitem" href="../comparison/">Model comparison</a></li><li><span class="tocitem">Extended examples</span><ul><li><a class="tocitem" href="../examples/03_calibration/notebook/">Calibration workflows</a></li><li><a class="tocitem" href="../examples/04_model_battle/notebook/">Model battle</a></li></ul></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li><a class="tocitem" href="../api/">Adding new models</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ablaom/TumorGrowth.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ablaom/TumorGrowth.jl/blob/dev/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><ul><li><a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth.TumorGrowth</code></a></li><li><a href="#TumorGrowth.CalibrationProblem-Tuple{CalibrationProblem}"><code>TumorGrowth.CalibrationProblem</code></a></li><li><a href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>TumorGrowth.CalibrationProblem</code></a></li><li><a href="#TumorGrowth.WeightedL2Loss"><code>TumorGrowth.WeightedL2Loss</code></a></li><li><a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy</code></a></li><li><a href="#TumorGrowth.bertalanffy2-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy2</code></a></li><li><a href="#TumorGrowth.bertalanffy2_ode!-NTuple{4, Any}"><code>TumorGrowth.bertalanffy2_ode!</code></a></li><li><a href="#TumorGrowth.bertalanffy_numerical-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy_numerical</code></a></li><li><a href="#TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}"><code>TumorGrowth.bertalanffy_ode</code></a></li><li><a href="#TumorGrowth.classical_bertalanffy-Tuple{Any, Any}"><code>TumorGrowth.classical_bertalanffy</code></a></li><li><a href="#TumorGrowth.compare-Tuple"><code>TumorGrowth.compare</code></a></li><li><a href="#TumorGrowth.curvature-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T"><code>TumorGrowth.curvature</code></a></li><li><a href="#TumorGrowth.delete-Tuple{NamedTuple, Any}"><code>TumorGrowth.delete</code></a></li><li><a href="#TumorGrowth.errors-Tuple{ModelComparison}"><code>TumorGrowth.errors</code></a></li><li><a href="#TumorGrowth.exponential-Tuple{Any, Any}"><code>TumorGrowth.exponential</code></a></li><li><a href="#TumorGrowth.fill_gaps-Tuple{Any, Any, Any}"><code>TumorGrowth.fill_gaps</code></a></li><li><a href="#TumorGrowth.flat_patient_data-Tuple{}"><code>TumorGrowth.flat_patient_data</code></a></li><li><a href="#TumorGrowth.force_constraints!-NTuple{4, Any}"><code>TumorGrowth.force_constraints!</code></a></li><li><a href="#TumorGrowth.frozen_default-Tuple{Any}"><code>TumorGrowth.frozen_default</code></a></li><li><a href="#TumorGrowth.functor-Tuple{Any}"><code>TumorGrowth.functor</code></a></li><li><a href="#TumorGrowth.functor-Tuple{Any, Any}"><code>TumorGrowth.functor</code></a></li><li><a href="#TumorGrowth.gompertz-Tuple{Any, Any}"><code>TumorGrowth.gompertz</code></a></li><li><a href="#TumorGrowth.guess_parameters-Tuple{Any, Any, Any}"><code>TumorGrowth.guess_parameters</code></a></li><li><a href="#TumorGrowth.iterations_default-Tuple{Any, Any}"><code>TumorGrowth.iterations_default</code></a></li><li><a href="#TumorGrowth.logistic-Tuple{Any, Any}"><code>TumorGrowth.logistic</code></a></li><li><a href="#TumorGrowth.loss-Tuple"><code>TumorGrowth.loss</code></a></li><li><a href="#TumorGrowth.lower_default-Tuple{Any}"><code>TumorGrowth.lower_default</code></a></li><li><a href="#TumorGrowth.merge-Tuple{Any, Any}"><code>TumorGrowth.merge</code></a></li><li><a href="#TumorGrowth.neural-Tuple"><code>TumorGrowth.neural</code></a></li><li><a href="#TumorGrowth.neural2-Tuple"><code>TumorGrowth.neural2</code></a></li><li><a href="#TumorGrowth.neural_ode-Tuple{Any, Any}"><code>TumorGrowth.neural_ode</code></a></li><li><a href="#TumorGrowth.optimiser_default-Tuple{Any}"><code>TumorGrowth.optimiser_default</code></a></li><li><a href="#TumorGrowth.parameters-Tuple{ModelComparison}"><code>TumorGrowth.parameters</code></a></li><li><a href="#TumorGrowth.patient_data-Tuple{}"><code>TumorGrowth.patient_data</code></a></li><li><a href="#TumorGrowth.penalty_default-Tuple{Any}"><code>TumorGrowth.penalty_default</code></a></li><li><a href="#TumorGrowth.radius_default-Tuple{Any, Any}"><code>TumorGrowth.radius_default</code></a></li><li><a href="#TumorGrowth.recover-Tuple{Any, Any}"><code>TumorGrowth.recover</code></a></li><li><a href="#TumorGrowth.satisfies_constraints-Tuple{Any, Any, Any}"><code>TumorGrowth.satisfies_constraints</code></a></li><li><a href="#TumorGrowth.scale_default-Tuple{Any, Any, Any}"><code>TumorGrowth.scale_default</code></a></li><li><a href="#TumorGrowth.slope-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T"><code>TumorGrowth.slope</code></a></li><li><a href="#TumorGrowth.solution-Tuple{CalibrationProblem}"><code>TumorGrowth.solution</code></a></li><li><a href="#TumorGrowth.solve!-Tuple"><code>TumorGrowth.solve!</code></a></li><li><a href="#TumorGrowth.upper_default-Tuple{Any}"><code>TumorGrowth.upper_default</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}" href="#TumorGrowth.CalibrationProblem-Tuple{Any, Any, Any}"><code>TumorGrowth.CalibrationProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">    CalibrationProblem(times, volumes, model; learning_rate=0.0001, options...)</code></pre><p>Specify a problem concerned with optimizing the parameters of a tumor growth <code>model</code>, given measured <code>volumes</code> and corresponding <code>times</code>.</p><p>See <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a> for a list of possible <code>model</code>s.</p><p>Default optimisation is by Adam gradient descent, using a sum of squares loss. Call <code>solve!</code> on a problem to carry out optimisation, as shown in the example below. See &quot;Extended Help&quot; for advanced options, including early stopping.</p><p>Initial values of the parameters are inferred by default.</p><p>Unless frozen (see &quot;Extended help&quot; below), the calibration process learns an initial condition <code>v0</code> which is generally different from <code>volumes[1]</code>.</p><p><strong>Simple solve</strong></p><pre><code class="language-julia hljs">using TumorGrowth

times = [0.1, 6.0, 16.0, 24.0, 32.0, 39.0]
volumes = [0.00023, 8.4e-5, 6.1e-5, 4.3e-5, 4.3e-5, 4.3e-5]
problem = CalibrationProblem(times, volumes, gompertz; learning_rate=0.01)
solve!(problem, 30)    # apply 30 gradient descent updates
julia&gt; loss(problem)   # sum of squares loss
1.7341026729860452e-9

p = solution(problem)
julia&gt; pretty(p)
&quot;v0=0.0002261  v∞=2.792e-5  ω=0.05731&quot;


extended_times = vcat(times, [42.0, 46.0])
julia&gt; gompertz(extended_times, p)[[7, 8]]
2-element Vector{Float64}:
 3.374100207406809e-5
 3.245628908921241e-5</code></pre><p><strong>Extended help</strong></p><p><strong>Solving with iteration controls</strong></p><p>Continuing the example above, we may replace the number of iterations, <code>n</code>, in <code>solve!(problem, n)</code>, with any control from IterationControl.jl:</p><pre><code class="language-julia hljs">using IterationControl
solve!(
  problem,
  Step(1),            # apply controls every 1 iteration...
  WithLossDo(),       # print loss
  Callback(problem -&gt; print(pretty(solution(problem)))), # print parameters
  InvalidValue(),     # stop for ±Inf/NaN loss
  NumberSinceBest(5), # stop when lowest loss so far was 5 steps prior
  TimeLimit(1/60),    # stop after one minute
  NumberLimit(400),   # stop after 400 steps
)
p = solution(problem)
julia&gt; loss(problem)
7.609310030658547e-10</code></pre><p>See <a href="https://github.com/JuliaAI/IterationControl.jl">IterationControl.jl</a> for all options.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Controlled iteration as above is not recommended if you specify <code>optimiser=LevenbergMarquardt()</code> or <code>optimiser=Dogleg()</code> because the internal state of these optimisers is reset at every <code>Step</code>. Instead, to arrange automatic stopping, use <code>solve!(problem, 0)</code>.</p></div></div><p><strong>Visualizing results</strong></p><pre><code class="language-julia hljs">using Plots
scatter(times, volumes, xlab=&quot;time&quot;, ylab=&quot;volume&quot;, label=&quot;train&quot;)
plot!(problem, label=&quot;prediction&quot;)</code></pre><p><strong>Keyword options</strong></p><ul><li><p><code>p0=guess_parameters(times, volumes, model)</code>: initial value of the model parameters.</p></li><li><p><code>lower</code>: named tuple indicating lower bounds on components of the model parameter <code>p</code>. For example, if <code>lower=(; v0=0.1)</code>, then this introduces the constraint <code>p.v0 &lt; 0.1</code>. The model-specific default value is <a href="#TumorGrowth.lower_default-Tuple{Any}"><code>TumorGrowth.lower_default(model)</code></a>.</p></li><li><p><code>upper</code>: named tuple indicating upper bounds on components of the model parameter <code>p</code>. For example, if <code>upper=(; v0=100)</code>, then this introduces the constraint <code>p.v0 &lt; 100</code>. The model-specific default value is <a href="#TumorGrowth.upper_default-Tuple{Any}"><code>TumorGrowth.upper_default(model)</code></a>.</p></li><li><p><code>frozen</code>: a named tuple, such as <code>(; v0=nothing, λ=1/2)</code>; indicating parameters to be frozen at specified values during optimisation; a <code>nothing</code> value means freeze at initial value. The model-specific default value is <a href="#TumorGrowth.frozen_default-Tuple{Any}"><code>TumorGrowth.frozen_default(model)</code></a>.</p></li><li><p><code>learning_rate &gt; 0</code>: learniing rate for Adam gradient descent optimisation. Ignored if <code>optimiser</code> is explicitly specified.</p></li><li><p><code>optimiser</code>: optimisation algorithm, which will be one of two varieties:</p><ul><li><p>A gradient descent optimiser: This must be from Optimisers.jl or implement the same API.</p></li><li><p>A Gauss-Newton optimiser: Either <code>LevenbergMarquardt()</code>, <code>Dogleg()</code>, provided by LeastSquaresOptim.jl (but re-exported by <code>TumorGrowth</code>).</p></li></ul><p>The model-specific default value is <a href="#TumorGrowth.optimiser_default-Tuple{Any}"><code>TumorGrowth.optimiser_default(model)</code></a>, unless <code>learning_rate</code> is specified, in which case it will be <code>Optimisers.Adam(learning_rate)</code>.</p></li><li><p><code>scale</code>: a scaling function with the property that <code>p = scale(q)</code> has a value of the same order of magnitude for the model parameters being optimised, whenever <code>q</code> has the same form as a model parameter <code>p</code> but with all values equal to one. Scaling can help components of <code>p</code> converge at a similar rate. Ignored by Gauss-Newton optimisers. Model-specific default is <a href="../api/#TumorGrowth.scale_default"><code>TumorGrowth.scale_default(model)</code></a>.</p></li><li><p><code>radius &gt; 0</code>: initial trust region radius. This is ignored unless <code>optimiser</code> is a Gauss-Newton optimiser. The model-specific default is <a href="#TumorGrowth.radius_default-Tuple{Any, Any}"><code>TumorGrowth.radius_default(model, optmiser)</code></a>, which is typically <code>10.0</code> for <code>LevenbergMarquardt()</code> and <code>1.0</code> for <code>Dogleg</code>.</p></li><li><p><code>half_life=Inf</code>: set to a real positive number to replace the sum of squares loss with a weighted version; weights decay in reverse time with the specified <code>half_life</code>. Ignored by Gauss-Newton optimisers.</p></li><li><p><code>penalty ≥ 0</code>: the larger the positive value, the more a loss penalty discourages large differences in <code>v0</code> and <code>v∞</code> on a log scale. Helps discourage <code>v0</code> and <code>v∞</code> drifting out of bounds in models whose ODE have a singularity at the origin. Model must include <code>v0</code> and <code>v∞</code> as parameters. Ignored by Gauss-Newton optimisers.  The model-specific default value is <a href="#TumorGrowth.penalty_default-Tuple{Any}"><code>TumorGrowth.penalty_default(model)</code></a>.</p></li><li><p><code>ode_options...</code>: optional keyword arguments for the ODE solver, <code>DifferentialEquations.solve</code>, from DifferentialEquations.jl. Not relevant for models using analytic solutions (see the table at <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/calibration.jl#L41-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.CalibrationProblem-Tuple{CalibrationProblem}" href="#TumorGrowth.CalibrationProblem-Tuple{CalibrationProblem}"><code>TumorGrowth.CalibrationProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CalibrationProblem(problem; kwargs...)</code></pre><p>Construct a new calibration problem out an existing <code>problem</code> but supply new keyword arguments, <code>kwargs</code>. Unspecified keyword arguments fall back to defaults, except for <code>p0</code>, which falls back to <code>solution(problem)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/calibration.jl#L254-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.bertalanffy-Tuple{Any, Any}" href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bertalanffy(times, p)</code></pre><p>Return volumes for specified <code>times</code>, based on the analytic solution to the General Bertalanffy model for lesion growth.  Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, <code>λ</code>, where <code>v0</code> is the volume at time <code>times[1]</code>. Other parameters are explained below.</p><p>Special cases of the model are:</p><ul><li><a href="#TumorGrowth.logistic-Tuple{Any, Any}"><code>logistic</code></a> (<code>λ = -1</code>)</li><li><a href="#TumorGrowth.classical_bertalanffy-Tuple{Any, Any}"><code>classical_bertalanffy</code></a>  (<code>λ = 1/3</code>)</li><li><a href="#TumorGrowth.gompertz-Tuple{Any, Any}"><code>gompertz</code></a> (<code>λ = 0</code>)</li></ul><p><strong>Underlying ODE</strong></p><p>In the General Bertalanffy model, the volume <span>$v &gt; 0$</span> evolves according to the differential equation</p><p><span>$dv/dt = ω B_λ(v_∞/v) v,$</span></p><p>where <span>$B_λ$</span> is the Box-Cox transformation, defined by <span>$B_λ(x) = (x^λ - 1)/λ$</span>, unless <span>$λ = 0$</span>, in which case, <span>$B_λ(x) = \log(x)$</span>. Here:</p><ul><li><p><span>$v_∞$</span>=<code>v∞</code> is the steady state solution, stable and unique, assuming <span>$ω &gt;  0$</span>; this is sometimes referred to as the <em>carrying capacity</em></p></li><li><p><span>$1/ω$</span> has the  units of time</p></li><li><p><span>$λ$</span> is dimensionless</p></li></ul><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/models/bertalanffy.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.bertalanffy2-Tuple{Any, Any}" href="#TumorGrowth.bertalanffy2-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bertalanffy2(times, p; capacity=false, solve_kwargs...)</code></pre><p>Return volumes for specified <code>times</code>, based on numerical solutions to a two-dimensional extension of General Bertalanffy model for lesion growth. Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, <code>λ</code>, <code>γ</code>, where <code>v0</code> is the volume at time <code>times[1]</code>.</p><p>The usual General Bertalanffy model is recovered when <code>γ=0</code>. In that case, using <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a>, which is based on an analytic solution, may be preferred. Other parameters are explained below.</p><p><strong>Keyword options</strong></p><ul><li><code>solve_kwargs</code>: optional keyword arguments for the ODE solver, <code>DifferentialEquations.solve</code>, from DifferentialEquations.jl.</li></ul><p><strong>Underlying ODE</strong></p><p>In this model the carrying capacity of the <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a> model, ordinarily fixed, is introduced as a new latent variable <span>$u(t)$</span>, which is allowed to evolve independently of the volume <span>$v(t)$</span>, at a rate in proportion to its magnitude:</p><p><span>$dv/dt = ω B_λ(u/v) v$</span></p><p><span>$du/dt = γωu$</span></p><p>Here <span>$B_λ$</span> is the Box-Cox transformation with exponent <span>$λ$</span>. See <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a>. Also:</p><ul><li><span>$1/ω$</span> has units of time</li><li><span>$λ$</span> is dimensionless</li><li><span>$γ$</span> is dimensionless</li></ul><p>Since <span>$u$</span> is a latent variable, its initial value, <code>v∞ ≡ u(times[1])</code>, is an additional model parameter.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/models/bertalanffy2.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.bertalanffy_numerical-Tuple{Any, Any}" href="#TumorGrowth.bertalanffy_numerical-Tuple{Any, Any}"><code>TumorGrowth.bertalanffy_numerical</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bertalanffy_numerical(times, p; solve_kwargs...)</code></pre><p><em>Provided for testing purposes.</em></p><p>Return volumes for specified <code>times</code>, based on numerical solutions to the General Bertalanffy model for lesion growth. Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, <code>λ</code>, where <code>v0</code> is the volume at time <code>times[1]</code>; <code>solve_kwargs</code> are optional keyword arguments for the ODE solver, <code>DifferentialEquations.solve</code>, from DifferentialEquations.jl.</p><p>Since it is based on analtic solutions, <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a> is the preferred alternative to this function.</p><div class="admonition is-category-important"><header class="admonition-header">Important</header><div class="admonition-body"><p>It is assumed without checking that <code>times</code> is ordered: <code>times == sort(times)</code>.</p></div></div><p>See also <a href="#TumorGrowth.bertalanffy2-Tuple{Any, Any}"><code>bertalanffy2</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/models/bertalanffy_numerical.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.classical_bertalanffy-Tuple{Any, Any}" href="#TumorGrowth.classical_bertalanffy-Tuple{Any, Any}"><code>TumorGrowth.classical_bertalanffy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">classical_bertalanffy(times, v0, v∞, ω)</code></pre><p>Return volumes for specified <code>times</code>, based on anaytic solutions to the classical Bertalanffy model for lesion growth. Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, where <code>v0</code> is the volume at time <code>times[1]</code>.</p><p>This is the <code>λ=1/3</code> case of the <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a> model.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/models/classical_bertalanffy.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.compare-Tuple" href="#TumorGrowth.compare-Tuple"><code>TumorGrowth.compare</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compare(times, volumes, models; holdouts=3, metric=mae, advanced_options...)</code></pre><p>By calibrating <code>models</code> using the specified patient <code>times</code> and lesion <code>volumes</code>, compare those models using a hold-out set consisting of the last <code>holdouts</code> data points.</p><pre><code class="language-julia hljs">times = [0.1, 6.0, 16.0, 24.0, 32.0, 39.0]
volumes = [0.00023, 8.4e-5, 6.1e-5, 4.3e-5, 4.3e-5, 4.3e-5]

julia&gt; comparison = compare(times, volumes, [gompertz, logistic])
ModelComparison with 3 holdouts:
  metric: mae
  gompertz:     2.198e-6
  logistic:     6.55e-6

julia&gt; errors(comparison)
2-element Vector{Float64}:
 2.197843662660861e-6
 6.549858321487298e-6

julia&gt; p = parameters(comparison)[1]  # calibrated parameter for `gompertz`
(v0 = 0.00022643603114569068, v∞ = 3.8453274218216947e-5, ω = 0.11537512108224635)

julia&gt; gompertz(times, p)
6-element Vector{Float64}:
 0.00022643603114569068
 9.435316392754094e-5
 5.1039159299783234e-5
 4.303209015899451e-5
 4.021112910411027e-5
 3.922743006690166e-5</code></pre><p><strong>Visualising comparisons</strong></p><pre><code class="language-julia hljs">using Plots
plot(comparison, title=&quot;A comparison of two models&quot;)</code></pre><p><strong>Keyword options</strong></p><ul><li><p><code>holdouts=3</code>: number of time-volume pairs excluded from the end of the calibration data</p></li><li><p><code>metric=mae</code>: metric applied to holdout set; the reported error on a model predicting volumes <code>v̂</code> is <code>metric(v̂, v)</code> where <code>v</code> is the last <code>holdouts</code> values of <code>volumes</code>. For example, any regression measure from StatisticalMeasures.jl can be used here. The built-in fallback is mean absolute error.</p></li><li><p><code>iterations=TumorGrowth.iterations.(models)</code>: a vector of iteration counts for the calibration of <code>models</code></p></li><li><p><code>calibration_options</code>: a vector of named tuples providing keyword arguments for the <code>CalibrationProblem</code> for each model. Possible keys are: <code>p0</code>, <code>lower</code>, <code>upper</code>, <code>frozen</code>, <code>learning_rate</code>, <code>optimiser</code>, <code>radius</code>, <code>scale</code>, <code>half_life</code>, <code>penalty</code>, and keys corresponding to any ODE solver options. Keys left unspecified fall back to defaults, as these are described in the <a href="../calibration/#TumorGrowth.CalibrationProblem"><code>CalibrationProblem</code></a> document string.</p></li></ul><p>See also <a href="#TumorGrowth.errors-Tuple{ModelComparison}"><code>errors</code></a>, <a href="#TumorGrowth.parameters-Tuple{ModelComparison}"><code>parameters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/compare.jl#L63-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.errors-Tuple{ModelComparison}" href="#TumorGrowth.errors-Tuple{ModelComparison}"><code>TumorGrowth.errors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">errors(comparison)</code></pre><p>Extract the the vector of errors from a <code>ModelComparison</code> object, as returned by calls to <a href="../comparison/#TumorGrowth.compare"><code>compare</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/compare.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.exponential-Tuple{Any, Any}" href="#TumorGrowth.exponential-Tuple{Any, Any}"><code>TumorGrowth.exponential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exponential(times, p)</code></pre><p>Return volumes for specified <code>times</code>, based on the analytic solution to the exponential model for lesion growth. Here <code>p</code> will have properties <code>v0</code> and <code>ω</code>, where <code>v0</code> is the volume at time <code>times[1]</code> and <code>log(2)/ω</code> is the half life. Use negative <code>ω</code> for growth and positive <code>ω</code> for decay.</p><p><strong>Underlying ODE</strong></p><p>In the exponential model, the volume <span>$v &gt; 0$</span> evolves according to the differential equation</p><p><span>$dv/dt = -ω v.$</span></p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/models/exponential.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.flat_patient_data-Tuple{}" href="#TumorGrowth.flat_patient_data-Tuple{}"><code>TumorGrowth.flat_patient_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">flat_patient_data()</code></pre><p>Return, in row table form, the lesion measurement data collected in Laleh et al. <a href="https://doi.org/10.1371/journal.pcbi.1009822">(2022)</a> &quot;Classical mathematical models for prediction of response to chemotherapy and immunotherapy&quot;, <em>PLOS Computational Biology</em>.</p><p>Each row represents a single measurement of a single lesion on some day.</p><p>See also <a href="../datasets/#TumorGrowth.patient_data"><code>patient_data</code></a>, in which each row represents all measurements of a single lesion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/patient_data.jl#L6-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.gompertz-Tuple{Any, Any}" href="#TumorGrowth.gompertz-Tuple{Any, Any}"><code>TumorGrowth.gompertz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gompertz(times, p)</code></pre><p>Return volumes for specified <code>times</code>, based on anaytic solutions to the classical Gompertz model for lesion growth. Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, where <code>v0</code> is the volume at time <code>times[1]</code>.</p><p>This is the <code>λ=0</code> case of the <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a> model.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/models/gompertz.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.guess_parameters-Tuple{Any, Any, Any}" href="#TumorGrowth.guess_parameters-Tuple{Any, Any, Any}"><code>TumorGrowth.guess_parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">guess_parameters(times, volumes, model)</code></pre><p>Apply heuristics to guess parameters <code>p</code> for a model.</p><p><strong>New model implementations</strong></p><p>Fallback returns <code>nothing</code> which will prompt user&#39;s to explicitly specify initial parameter values in calibration problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/api.jl#L15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.logistic-Tuple{Any, Any}" href="#TumorGrowth.logistic-Tuple{Any, Any}"><code>TumorGrowth.logistic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logistic(times, v0, v∞, ω)</code></pre><p>Return volumes for specified <code>times</code>, based on anaytic solutions to the classical logistic (Verhulst) model for lesion growth. Here <code>p</code> will have properties <code>v0</code>, <code>v∞</code>, <code>ω</code>, where <code>v0</code> is the volume at time <code>times[1]</code>.</p><p>This is the <code>λ=-1</code> case of the <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a> model.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/models/logistic.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.loss-Tuple" href="#TumorGrowth.loss-Tuple"><code>TumorGrowth.loss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loss(problem)</code></pre><p>Return the sum of squares loss for a calibration <code>problem</code>, as constructed with <a href="../calibration/#TumorGrowth.CalibrationProblem"><code>CalibrationProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/optimisers.jl#L329-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.neural-Tuple" href="#TumorGrowth.neural-Tuple"><code>TumorGrowth.neural</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neural([rng,] network; transform=log, inverse=exp)</code></pre><p>Initialize the Lux.jl neural network, <code>network</code>, and return a callable object, <code>model</code>, for solving the associated one-dimensional neural ODE for volume growth, as detailed under &quot;Underlying ODE&quot; below.</p><p>The returned object, <code>model</code>, is called like this:</p><pre><code class="nohighlight hljs">volumes = model(times, p)</code></pre><p>where <code>p</code> should have properties <code>v0</code>, <code>v∞</code>, <code>θ</code>, where <code>v0</code> is the initial volume (so that <code>volumes[1] = v0</code>), <code>v∞</code> is a volume scale parameter, and <code>θ</code> is a <code>network</code>-compatible Lux.jl parameter.</p><p>It seems that calibration works best if <code>v∞</code> is frozen.</p><p>The form of <code>θ</code> is the same as <code>TumorGrowth.initial_parameters(model)</code>, which is also the default initial value used when solving an associated <a href="../calibration/#TumorGrowth.CalibrationProblem"><code>CalibrationProblem</code></a>.</p><pre><code class="language-julia hljs">using Lux, Random

# define neural network with 1 input and 1 output:
network = Lux.Chain(Dense(1, 3, Lux.tanh; init_weight=Lux.zeros64), Dense(3, 1))

rng = Xoshiro(123)
model = neural(rng, network)
θ = TumorGrowth.initial_parameters(model)
times = [0.1, 6.0, 16.0, 24.0, 32.0, 39.0]
v0, v∞ = 0.00023, 0.00015
p = (; v0, v∞, θ)

julia&gt; volumes = model(times, p) # (constant because of zero-initialization)
6-element Vector{Float64}:
 0.00023
 0.00023
 0.00023
 0.00023# # Neural2</code></pre><p><strong>Underlying ODE</strong></p><p>View the neural network (with fixed parameter <code>θ</code>) as a mathematical function <span>$f$</span> and write <span>$ϕ$</span> for the <code>transform</code> function. Then <span>$v(t) = v_∞ ϕ^{-1}(y(t))$</span>, where <span>$y(t)$</span> evolves according to</p><p><span>$dy/dt = f(y)$</span></p><p>subject to the initial condition <span>$y(t₀) = ϕ(v_0/v_∞)$</span>, where <span>$t₀$</span> is the initial time, <code>times[1]</code>. We are writing <span>$v₀$</span>=<code>v0</code> and <span>$v_∞$</span>=<code>v∞</code>.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>.  See also <a href="../calibration/#TumorGrowth.CalibrationProblem"><code>CalibrationProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/models/neural.jl#L7-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.neural2-Tuple" href="#TumorGrowth.neural2-Tuple"><code>TumorGrowth.neural2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">neural2([rng,] network; transform=log, inverse=exp)</code></pre><p>Initialize the Lux.jl neural network, <code>network</code>, and return a callable object, <code>model</code>, for solving the associated two-dimensional neural ODE for volume growth, as detailed under &quot;Underlying ODE&quot; below.</p><p>The returned object <code>model</code> is called like this:</p><pre><code class="nohighlight hljs">volumes = model(times, p)</code></pre><p>where <code>p</code> should have properties <code>v0</code>, <code>v∞</code>, <code>θ</code>, where <code>v0</code> is the initial volume (so that <code>volumes[1] = v0</code>), <code>v∞</code> is a volume scale parameter, and <code>θ</code> is a <code>network</code>-compatible Lux.jl parameter.</p><p>It seems that calibration works best if <code>v∞</code> is frozen.</p><p>The form of <code>θ</code> is the same as <code>TumorGrowth.initial_parameters(model)</code>, which is also the default initial value used when solving an associated <a href="../calibration/#TumorGrowth.CalibrationProblem"><code>CalibrationProblem</code></a>.</p><pre><code class="language-julia hljs">using Lux, Random

# define neural network with 2 inputs and 2 outputs:
network = Lux.Chain(Dense(2, 3, Lux.tanh; init_weight=Lux.zeros64), Dense(3, 2))

rng = Xoshiro(123)
model = neural2(rng, network)
θ = TumorGrowth.initial_parameters(model)
times = [0.1, 6.0, 16.0, 24.0, 32.0, 39.0]
v0, v∞ = 0.00023, 0.00015
p = (; v0, v∞, θ)

julia&gt; volumes = model(times, p) # (constant because of zero-initialization)
6-element Vector{Float64}:
 0.00023
 0.00023
 0.00023
 0.00023
 0.00023
 0.00023</code></pre><p><strong>Underlying ODE</strong></p><p>View the neural network (with fixed parameter <code>θ</code>) as a mathematical function <span>$f$</span>, with components <span>$f₁$</span> and <span>$f₂$</span>, and write <span>$ϕ$</span> for the <code>transform</code> function. Then <span>$v(t) = v_∞ ϕ^{-1}(y(t))$</span>, where <span>$y(t)$</span>, and a latent variable <span>$u(t)$</span>, evolve according to</p><p><span>$dy/dt = f₁(y, u)$</span></p><p><span>$du/dt = f₂(y, u)$</span></p><p>subject to the initial conditions <span>$y(t₀) = ϕ(v₀/v_∞)$</span>, <span>$u(t₀) = 1$</span>, where <span>$t₀$</span> is the initial time, <code>times[1]</code>. We are writing <span>$v₀$</span>=<code>v0</code> and <span>$v_∞$</span>=<code>v∞</code>.</p><p>For a list of all models see <a href="#TumorGrowth.TumorGrowth"><code>TumorGrowth</code></a>.  See also <a href="../calibration/#TumorGrowth.CalibrationProblem"><code>CalibrationProblem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/models/neural2.jl#L7-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.parameters-Tuple{ModelComparison}" href="#TumorGrowth.parameters-Tuple{ModelComparison}"><code>TumorGrowth.parameters</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parameters(comparison)</code></pre><p>Extract the the vector of parameters from a <code>ModelComparison</code> object, as returned by calls to <a href="../comparison/#TumorGrowth.compare"><code>compare</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/compare.jl#L136-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.patient_data-Tuple{}" href="#TumorGrowth.patient_data-Tuple{}"><code>TumorGrowth.patient_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">patient_data()</code></pre><p>Return, in row table form, the lesion measurement data collected in Laleh et al. <a href="https://doi.org/10.1371/journal.pcbi.1009822">(2022)</a> &quot;Classical mathematical models for prediction of response to chemotherapy and immunotherapy&quot;, <em>PLOS Computational Biology</em>.</p><p>Each row represents all measurements for a single lesion for a unique patient.</p><pre><code class="language-julia hljs">record = first(patient_data())

julia&gt; record.Pt_hashID # patient identifier
&quot;0218075314855e6ceacca856fcd4c737-S1&quot;

julia&gt; record.T_weeks # measure times, in weeks
7-element Vector{Float64}:
  0.1
  6.0
 12.0
 17.0
 23.0
 29.0
 35.0

julia&gt; record.Lesion_normvol # all volumes measured, normalised by dataset max
7-element Vector{Float64}:
 0.000185364052636979
 0.00011229838600811
 8.4371439525252e-5
 8.4371439525252e-5
 1.05464299406565e-5
 2.89394037571615e-5
 8.4371439525252e-5</code></pre><p>See also <a href="../datasets/#TumorGrowth.flat_patient_data"><code>flat_patient_data</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/patient_data.jl#L50-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.solution-Tuple{CalibrationProblem}" href="#TumorGrowth.solution-Tuple{CalibrationProblem}"><code>TumorGrowth.solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solution(problem)</code></pre><p>Return to the solution to a <a href="../calibration/#TumorGrowth.CalibrationProblem"><code>CalibrationProblem</code></a>. Normally applied after calling <a href="#TumorGrowth.solve!-Tuple"><code>solve!(problem)</code></a>.</p><p>Also returns the solution to internally defined problems, as constructed with <code>TumorGrowth.OptimisationProblem</code>, <code>TumorGrowth.CurveOptimisationProblem</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/calibration.jl#L276-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.solve!-Tuple" href="#TumorGrowth.solve!-Tuple"><code>TumorGrowth.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(problem, n)</code></pre><p>Solve a calibration <code>problem</code>, as constructed with <a href="../calibration/#TumorGrowth.CalibrationProblem"><code>CalibrationProblem</code></a>. The calibrated parameters are then returned by <code>solution(problem)</code>.</p><p>If using a Gauss-Newton optimiser (<code>LevenbergMarquardt</code> or <code>Dogleg</code>) specify <code>n=0</code> to choose <code>n</code> automatically.</p><hr/><pre><code class="nohighlight hljs">solve!(problem, controls...)</code></pre><p>Solve a calibration <code>problem</code> using one or more iteration <code>controls</code>, from the package IterationControls.jl. See the &quot;Extended help&quot; section of <a href="../calibration/#TumorGrowth.CalibrationProblem"><code>CalibrationProblem</code></a> for examples.</p><p>Not recommended for Gauss-Newton optimisers (<code>LevenbergMarquardt</code> or <code>Dogleg</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/optimisers.jl#L306-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.TumorGrowth" href="#TumorGrowth.TumorGrowth"><code>TumorGrowth.TumorGrowth</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>TumorGrowth.jl provides the following models for tumor growth:</p><table><tr><th style="text-align: left">model</th><th style="text-align: left">description</th><th style="text-align: left">parameters, <code>p</code></th><th style="text-align: left">analytic?</th></tr><tr><td style="text-align: left"><a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a></td><td style="text-align: left">General Bertalanffy (GB)</td><td style="text-align: left"><code>(; v0, v∞, ω, λ)</code></td><td style="text-align: left">yes</td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.bertalanffy_numerical-Tuple{Any, Any}"><code>bertalanffy_numerical</code></a></td><td style="text-align: left">General Bertalanffy (testing only)</td><td style="text-align: left"><code>(; v0, v∞, ω, λ)</code></td><td style="text-align: left">no</td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.bertalanffy2-Tuple{Any, Any}"><code>bertalanffy2</code></a></td><td style="text-align: left">2D extension of General Bertalanffy</td><td style="text-align: left"><code>(; v0, v∞, ω, λ, γ)</code></td><td style="text-align: left">no</td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.gompertz-Tuple{Any, Any}"><code>gompertz</code></a></td><td style="text-align: left">classical Gompertz (GB, <code>λ=0</code>)</td><td style="text-align: left"><code>(; v0, v∞, ω)</code></td><td style="text-align: left">yes</td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.logistic-Tuple{Any, Any}"><code>logistic</code></a></td><td style="text-align: left">classical Logistic/Verhulst (GB, <code>λ=-1</code>)</td><td style="text-align: left"><code>(; v0, v∞, ω)</code></td><td style="text-align: left">yes</td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.classical_bertalanffy-Tuple{Any, Any}"><code>classical_bertalanffy</code></a></td><td style="text-align: left">classical Bertalanffy (GB, <code>λ=1/3</code>)</td><td style="text-align: left"><code>(; v0, v∞, ω)</code></td><td style="text-align: left">yes</td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.exponential-Tuple{Any, Any}"><code>exponential</code></a></td><td style="text-align: left">exponential decay or growth</td><td style="text-align: left"><code>(; v0, ω)</code></td><td style="text-align: left">yes</td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.neural-Tuple"><code>neural(rng, network)</code></a></td><td style="text-align: left">1D neural ODE with Lux.jl <code>network</code></td><td style="text-align: left"><code>(; v0, v∞, θ)</code></td><td style="text-align: left">no</td></tr><tr><td style="text-align: left"><a href="#TumorGrowth.neural2-Tuple"><code>neural2(rng, network)</code></a></td><td style="text-align: left">2D neural ODE with Lux.jl <code>network</code></td><td style="text-align: left"><code>(; v0, v∞, θ)</code></td><td style="text-align: left">no</td></tr></table><p>Here a <em>model</em> is a callable object, that outputs a sequence of lesion volumes, given times, by solving a related ordinary differential equation with parameters (<code>p</code> below):</p><pre><code class="language-julia hljs">using TumorGrowth

times = times = [0.1, 6.0, 16.0, 24.0, 32.0, 39.0]
p = (v0=0.0002261, v∞=2.792e-5,  ω=0.05731) # `v0` is the initial volume
volumes = gompertz(times, p)
6-element Vector{Float64}:
 0.0002261
 0.0001240760197801191
 6.473115210101774e-5
 4.751268597529182e-5
 3.9074807723757934e-5
 3.496675045077041e-5</code></pre><p>In every model, <code>v0</code> is the initial volume, so that <code>volumes[1] == v0</code>.</p><p>In the case analytic solutions to the underlying ODEs are not known, optional keyword arguments for the <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a> solver can be passed to the model call.</p><p>TumorGrowth.jl also provides a <a href="../calibration/#TumorGrowth.CalibrationProblem"><code>CalibrationProblem</code></a> tool to calibrate model parameters, and a <a href="../comparison/#TumorGrowth.compare"><code>compare</code></a> tool to compare models on a holdout set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/TumorGrowth.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.WeightedL2Loss" href="#TumorGrowth.WeightedL2Loss"><code>TumorGrowth.WeightedL2Loss</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightedL2Loss(times, h=Inf)</code></pre><p><strong>Private method.</strong></p><p>Return a weighted sum of squares loss function <code>(ŷ, y) -&gt; loss</code>, where the weights decay in reverse time with a half life <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/tools.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.bertalanffy2_ode!-NTuple{4, Any}" href="#TumorGrowth.bertalanffy2_ode!-NTuple{4, Any}"><code>TumorGrowth.bertalanffy2_ode!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bertalanffy2_ode!(dX, X, p, t)</code></pre><p>A two-dimensional extension of the ODE describing the General Bertalanffy model for lesion growth.  Here <code>X = [v, u]</code>, where <code>v</code> is volume at time <code>t</code> and <code>u</code> is the &quot;carrying capacity&quot; at time <code>t</code>, a latent variable. The time derivatives are written to <code>dX</code>. For the specific form of the ODE, see <a href="#TumorGrowth.bertalanffy2-Tuple{Any, Any}"><code>bertalanffy2</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/odes.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}" href="#TumorGrowth.bertalanffy_ode-Tuple{Any, Any, Any}"><code>TumorGrowth.bertalanffy_ode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bertalanffy_ode(v, p, t)</code></pre><p>Based on the General Bertalanffy model, return the rate in change in volume at time <code>t</code>, for a current volume of <code>v</code>. For details, see <a href="#TumorGrowth.bertalanffy-Tuple{Any, Any}"><code>bertalanffy</code></a>.</p><p>Note here that <code>v</code>, and the return value, are <em>vectors</em> with a single element, rather than scalars.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/odes.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.curvature-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T" href="#TumorGrowth.curvature-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T"><code>TumorGrowth.curvature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">curvature(xs, ys)</code></pre><p>Return the coefficient <code>a</code> for the parabola <code>x -&gt; a*x^2 + b*x + c</code> of best fit, for ordinates <code>xs</code> and coordinates <code>ys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/tools.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.delete-Tuple{NamedTuple, Any}" href="#TumorGrowth.delete-Tuple{NamedTuple, Any}"><code>TumorGrowth.delete</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delete(x, kys)</code></pre><p><strong>Private method.</strong></p><p>Assuming <code>x</code> is a named tuple, return a copy of <code>x</code> with any key in <code>kys</code> removed. Otherwise, assuming <code>x</code> is a structured object (such as a <code>ComponentArray</code>) first convert to a named tuple and then delete the specified keys.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/tools.jl#L98-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.fill_gaps-Tuple{Any, Any, Any}" href="#TumorGrowth.fill_gaps-Tuple{Any, Any, Any}"><code>TumorGrowth.fill_gaps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fill_gaps(short, long, filler)</code></pre><p><strong>Private method.</strong></p><p>Here <code>long</code> is a <code>ComponentArray</code> and <code>short</code> a named tuple with some of the keys from <code>long</code>. The method returns a <code>ComponentArray</code> with the same structure as <code>long</code> but with the values of <code>short</code> merged into <code>long</code>, with all other (possibly nested) values replaced with <code>filler</code> for numerical values or arrays of <code>Inf</code> in the case of array values.</p><p>``<code>julia long = (a=1, b=rand(1,2), c=(d=4, e=rand(2))) |&gt; ComponentArray short = (; a=10) # could alternatively be a</code>ComponentArray`</p><p>julia&gt; TumorGrowth.fill_gaps(short, long, Inf) filled = ComponentVector{Float64}(a = 10.0, b = [Inf Inf], c = (d = Inf, e = [Inf, Inf]))</p><p>julia&gt; all(filled .&gt; long) true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/tools.jl#L176-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.force_constraints!-NTuple{4, Any}" href="#TumorGrowth.force_constraints!-NTuple{4, Any}"><code>TumorGrowth.force_constraints!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">force_constraints!(x_candidate, x, lower, upper)</code></pre><p><strong>Private method.</strong></p><p>Assumes <code>x</code> is a <code>ComponentArray</code> for which <a href="#TumorGrowth.satisfies_constraints-Tuple{Any, Any, Any}"><code>TumorGrowth.satisfies_constraints(x, lower, upper)</code></a> is <code>true</code>. The method mutates those components of the <code>x_candidate</code> which do not satisfy the constraints by moving from <code>x</code> towards the boundary half the distance to the boundary, along the failed component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/tools.jl#L146-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.frozen_default-Tuple{Any}" href="#TumorGrowth.frozen_default-Tuple{Any}"><code>TumorGrowth.frozen_default</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">frozen_default(model)</code></pre><p>Return a named tuple indicating parameter values to be frozen by default when calibrating <code>model</code>. A value of <code>nothing</code> for a parameter indicates freezing at initial value.</p><p><strong>New model implementations</strong></p><p>Fallback returns an empty named tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/api.jl#L60-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.functor-Tuple{Any, Any}" href="#TumorGrowth.functor-Tuple{Any, Any}"><code>TumorGrowth.functor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function TumorGrowth.functor(x, frozen)</code></pre><p><strong>Private method.</strong></p><p>For a <code>ComponentArray</code>, <code>x</code>, return a tuple <code>(xfree, reconstructor)</code>, where:</p><ul><li><p><code>xfree</code> is a deconstructed version of <code>x</code> with entries corresponding to keys in the ordinary named tuple <code>frozen</code> deleted.</p></li><li><p><code>reconstruct</code> is a method to reconstruct a <code>ComponentArray</code> from something similar to <code>xfree</code>, ensuring the missing keys get values from the named tuple <code>frozen</code>, as demonstrated in the example below. You can also apply <code>reconstruct</code> to things like <code>xfree</code> wrapped as <code>ComponentArray</code>s.</p></li></ul><pre><code class="language-julia hljs">
c = (x =1, y=2, z=3) |&gt; ComponentArray
free, reconstruct = TumorGrowth.functor(c, (; y=20))
julia&gt; free
(x = 1, z = 3)

julia&gt; reconstruct((x=100, z=300))
ComponentVector{Int64}(x = 100, y = 20, z = 300)

julia&gt; reconstruct(ComponentArray(x=100, z=300)))
ComponentVector{Int64}(x = 100, y = 20, z = 300)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/functor.jl#L18-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.functor-Tuple{Any}" href="#TumorGrowth.functor-Tuple{Any}"><code>TumorGrowth.functor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TumorGrowth.functor(x) -&gt; destructured_x, recover</code></pre><p><strong>Private method.</strong></p><p>An extension of <code>Functors.functor</code> from the package Functors.jl, with an overloading for <code>ComponentArray</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/functor.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.iterations_default-Tuple{Any, Any}" href="#TumorGrowth.iterations_default-Tuple{Any, Any}"><code>TumorGrowth.iterations_default</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iterations_default(model, optimiser)</code></pre><p>Number of iterations, when calibrating <code>model</code> and using <code>optimiser</code>, to be adopted by default in model comparisons. Here <code>optimiser</code> is an optimiser from Optimisers.jl, or implements the same API, or is one of: <code>LevenbergMarquardt()</code>, or <code>Dogleg()</code>. .</p><p><strong>New model implementations</strong></p><p>Fallback returns <code>10000</code>, unless <code>optimiser isa Union{LevenbergMarquardt,Dogleg}</code>, in which case <code>0</code> is returned (stopping controlled by LeastSquaresOptim.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/api.jl#L147-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.lower_default-Tuple{Any}" href="#TumorGrowth.lower_default-Tuple{Any}"><code>TumorGrowth.lower_default</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lower_default(model)</code></pre><p>Return a named tuple with the lower bound constraints on parameters for  <code>model</code>.</p><p>For example, a return value of <code>(v0 = 0.1,)</code> indicates that <code>p.v0 &gt; 0.1</code> is a hard constraint for <code>p</code>, in calls of the form <code>model(times, p)</code>, but all other components of <code>p</code> are unconstrained.</p><p><strong>New model implementations</strong></p><p>Fallback returns <code>NamedTuple()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/api.jl#L28-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.merge-Tuple{Any, Any}" href="#TumorGrowth.merge-Tuple{Any, Any}"><code>TumorGrowth.merge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TumorGrowth.merge(x, y::NamedTuple)</code></pre><p><strong>Private method.</strong></p><p>Ordinary merge if <code>x</code> is also a named tuple. More generally, first deconstruct <code>x</code> using <code>TumorGrowth.functor</code>, merge as usual, and reconstruct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/tools.jl#L83-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.neural_ode-Tuple{Any, Any}" href="#TumorGrowth.neural_ode-Tuple{Any, Any}"><code>TumorGrowth.neural_ode</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>neural_ode([rng,] network)</p><p>Initialize the Lux.jl neural2 network, <code>network</code>, and return an associated ODE, <code>ode</code>, with calling syntax <code>dX_dt = ode(X, p, t)</code>, where <code>p</code> is a <code>network</code>-compatible parameter.</p><p>The initialized parameter value can be recovered with <code>TumorGrowth.initial_parameters(ode)</code>. Get the network state with <code>TumorGrowth.state(ode)</code>.</p><pre><code class="language-julia hljs">using Lux
using Random

rng = Xoshiro(123)
network = network = Lux.Chain(Lux.Dense(2, 3, Lux.tanh), Lux.Dense(3, 2))
ode = neural_ode(rng, network)
θ = TumorGrowth.initial_parameters(ode)
ode(rand(2), θ, 42.9) # last argument irrelevant as `ode` is autonomous</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/odes.jl#L53-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.optimiser_default-Tuple{Any}" href="#TumorGrowth.optimiser_default-Tuple{Any}"><code>TumorGrowth.optimiser_default</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimiser_default(model)</code></pre><p>Return the default choice of optimiser for <code>model</code>.</p><p><strong>New model implementations</strong></p><p>Must return an optimiser from Optimisers.jl, or an optimiser with the same API, or one of the optimisers from LeastSquaresOptim.jl, such as <code>LevenbergMarquardt()</code> or <code>Dogleg()</code>.</p><p>The fallback returns <code>Optimisers.Adam(0.0001)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/api.jl#L73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.penalty_default-Tuple{Any}" href="#TumorGrowth.penalty_default-Tuple{Any}"><code>TumorGrowth.penalty_default</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">penalty_default(model)</code></pre><p>Return the default loss <code>penalty</code> to be used when calibrating <code>model</code>. The larger the positive value, the more calibration discourages large differences in <code>v0</code> and <code>v∞</code> on a log scale. Helps discourage <code>v0</code> and <code>v∞</code> drifting out of bounds in models whose ODE have a singularity at the origin.</p><p>Ignored by the optimisers <code>LevenbergMarquardt()</code> and <code>Dogleg()</code>.</p><p><strong>New model implementations</strong></p><p>Must return a value in the range <span>$[0, ∞)$</span>, and will typically be less than <code>1.0</code>. Only implement if <code>model</code> has strictly positive parameters named <code>v0</code> and <code>v∞</code>.</p><p>Fallback returns <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/api.jl#L104-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.radius_default-Tuple{Any, Any}" href="#TumorGrowth.radius_default-Tuple{Any, Any}"><code>TumorGrowth.radius_default</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radius_default(model, optimiser)</code></pre><p>Return the default value of <code>radius</code> when calibrating <code>model</code> using <code>optimiser</code>. This is the initial trust region radius, which is named <code>Δ</code> in LeastSquaresOptim.jl documentation and code.</p><p>This parameter is ignored unless <code>optimiser</code>, as passed to the <code>CalibrationProblem</code>, is <code>LevenbergMarquardt()</code> or <code>Dogleg()</code>.</p><p><strong>New model implementations</strong></p><p>The fallback returns:</p><ul><li><code>10.0</code> if <code>optimiser isa</code>LevenbergMarquardt`</li><li><code>1.0</code> if <code>optimiser isa</code>Dogleg`</li><li><code>0</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/api.jl#L124-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.recover-Tuple{Any, Any}" href="#TumorGrowth.recover-Tuple{Any, Any}"><code>TumorGrowth.recover</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">recover(tuple, from)</code></pre><p><em>Private method.</em></p><p>Return a new named tuple by replacing any <code>nothing</code> values with the corresponding value in the <code>from</code> named tuple, whenever a corresponding key exists, and otherwise ignore.</p><pre><code class="language-julia hljs">julia&gt; recover((x=1, y=nothing, z=3, w=nothing), (x=10, y=2, k=7))
(x = 1, y = 2, z = 3, w = nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/tools.jl#L60-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.satisfies_constraints-Tuple{Any, Any, Any}" href="#TumorGrowth.satisfies_constraints-Tuple{Any, Any, Any}"><code>TumorGrowth.satisfies_constraints</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">satisfies_constraints(x, lower, upper)</code></pre><p><strong>Private method.</strong></p><p>Returns <code>true</code> if both of the following are true:</p><ul><li><code>upper.k &lt; x.k</code> for each <code>k</code> appearing as a key of <code>upper</code></li><li><code>x.k &lt; lower.k</code> for each <code>k</code> appearing as a key of <code>lower</code></li></ul><p>Otherwise, returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/tools.jl#L123-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.scale_default-Tuple{Any, Any, Any}" href="#TumorGrowth.scale_default-Tuple{Any, Any, Any}"><code>TumorGrowth.scale_default</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale_default(times, volumes, model)</code></pre><p>Return an appropriate default for a function <code>p -&gt; f(p)</code> so that <code>p = f(q)</code> has a value of the same order of magnitude expected for parameters of <code>model</code>, whenever <code>q</code> has the same form as <code>p</code> but with all values equal to one.</p><p>Ignored by the optimisers <code>LevenbergMarquardt()</code> and <code>Dogleg()</code>.</p><p><strong>New model implementations</strong></p><p>Fallback returns the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/api.jl#L88-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.slope-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T" href="#TumorGrowth.slope-Union{Tuple{T}, Tuple{AbstractArray{T}, Any}} where T"><code>TumorGrowth.slope</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">slope(xs, ys)</code></pre><p>Return the slope of the line of least-squares best fit for ordinates <code>xs</code> and coordinates <code>ys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/tools.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TumorGrowth.upper_default-Tuple{Any}" href="#TumorGrowth.upper_default-Tuple{Any}"><code>TumorGrowth.upper_default</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">upper_default(model)</code></pre><p>Return a named tuple with the upper bound constraints on the parameters for <code>model</code>.</p><p>For example, a return value of <code>(v0 = 1.0,)</code> indicates that <code>p.v0 &lt; 1.0</code> is a hard constraint for <code>p</code>, in calls of the form <code>model(times, p)</code>, but all other components of <code>p</code> are unconstrained.</p><p><strong>New model implementations</strong></p><p>Fallback returns empty named tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ablaom/TumorGrowth.jl/blob/1b398587a326d89bfa7ceddbf6547686b5e5669e/src/api.jl#L44-L57">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« Adding new models</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 19 November 2024 21:44">Tuesday 19 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
